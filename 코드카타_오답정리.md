<details>
<summary> 템플릿 </summary>
 
- To Do List
    - [x]
    - [ ]

- Today I Learned
</details>

<details>
<summary> 8/18 </summary>

### ⬛두수의 나눗셈
문제 설명
정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 solution 함수를 완성해주세요.

제한사항
0 < num1 ≤ 100
0 < num2 ≤ 100
```cpp
  #include <string>
  #include <vector>
  
  using namespace std;
  
  int solution(int num1, int num2) {
     int answer = ((double)num1/(double)num2)*1000;
     return answer;
  }
```

-> int형의 나누기를 할 때 소수점을 얻으려면 double형으로 형변환을 해주어야 한다. (float, long double도 가능)

-----------------------------------------------------------------------------------------
### ⬛각도기

각에서 0도 초과 90도 미만은 예각, 90도는 직각, 90도 초과 180도 미만은 둔각 180도는 평각으로 분류합니다. 
각 angle이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4를 return하도록 solution 함수를 완성해주세요.

예각 : 0 < angle < 90

직각 : angle = 90

둔각 : 90 < angle < 180

평각 : angle = 180

제한사항
0 < angle ≤ 180
angle은 정수입니다.
```cpp
 #include <string>
 #include <vector>
 
 using namespace std;
 
 int solution(int angle) 
 {
     if(0 < angle&&angle < 90)
         return 1;
     else if(angle == 90)
         return 2; 
     else if(90 < angle && angle < 180)
         return 3;
     else if(angle == 180)
         return 4;
 }
```

-> C++에서는 0 < angle < 90가 두 번의 비교가 아니라,
0 < angle 먼저 평가되어 결과가 true(1) 또는 false(0)이 됨
그 결과와 90을 비교 (즉, true(1) < 90 → 항상 참)


-> 다른 풀이 ( 삼항 연산자 사용 )
```cpp
 int solution(int angle) 
 {
     return angle % 90 == 0 ? angle / 90 * 2 : (angle / 90) * 2 + 1; 
 }
```
-----------------------------------------------------------------------------------------

### ⬛짝수의 합

정수 n이 주어질 때, n이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요.

제한사항
0 < n ≤ 1000
```cpp
 int solution(int n) 
 {
     int sum = 0;
     for( int i = 2; i <= n; i += 2) // 2부터 n까지 2씩 증가(짝수만)
     {
         sum += i;
     }
     return sum;
 }
```

-> 짝수 검사를 추가해서 다음과 같이 구현 할수도 있다.
```cpp
 for (int i = 1; i <= n; i++) 
 {
     if (i % 2 == 0) 
     {
         sum += i;
     }
 }
```

-> 다른 풀이 
```cpp
 int solution(int n) 
 {
     int answer = n/2;
     answer *= answer + 1;
     return answer;
 }
   //or
 int solution(int n) 
 {  return (n>>1) * ((n>>1) + 1);  }
```

1. 비트 연산자 >> 의미
  '>>'는 비트 오른쪽 시프트 연산자입니다.

   n >> 1은 n을 2로 나눈 것과 동일합니다 (정수 나눗셈, 소수점 이하 버림).

   예: 6 (110₂) >> 1 = 3 (011₂)
   
   예: 5 (101₂) >> 1 = 2 (010₂)

3. 식 해석
 (n >> 1) 은 n / 2와 같습니다.
 따라서 식은 수학적으로
<img width="184" height="58" alt="image" src="https://github.com/user-attachments/assets/d7bb4b1a-5ee0-46cd-9a72-4fc3db069365" />

 즉, n을 2로 나눈 몫에 그 몫 + 1을 곱하는 값입니다.
 

</details>

<details>
<summary> 25.08.19 </summary>

# ⬛평균구하기

정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.

제한사항

arr은 길이 1 이상, 100 이하인 배열입니다.
 
arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.
  ```cpp
  #include <string>
  #include <vector>
  
  using namespace std;
  
  double solution(vector<int> arr) 
  {
      long long sum = 0;
      for (int num : arr)
      {
          sum += num;
      }
      return static_cast<double>(sum) / arr.size();
  }
  ```

합이 최대 100 * 10000 = 1,000,000 정도인데, 여유 있게 long long으로 선언해 오버플로우 방지.
평균은 실수형 정확도를 위해 double로 반환합니다.
static_cast<double>로 실수 나눗셈을 보장합니다.

-> 다른 풀이
 ```cpp
 #include <string>
 #include <vector>
 #include <numeric>
 using namespace std;
 
 double solution(vector<int> arr) 
 {
     double answer = accumulate(arr.begin(), arr.end(), 0);
 
     return answer / arr.size();
 }
 ```

1. `#include <numeric>`  
* 이것은 C++ STL의 `<numeric>` 헤더로, `accumulate` 함수를 사용하기 위해 포함합니다.  
2. `accumulate(arr.begin(), arr.end(), 0)`  
* `accumulate` 함수는 STL 알고리즘 중 하나로,  
  `arr` 벡터의 처음부터 끝까지(`arr.begin()`, `arr.end()`) 원소들을 모두 더하는 역할을 합니다.  
* 세 번째 인자인 `0`은 초기 합계값입니다.  
* 결과적으로 `arr` 벡터 원소의 총합을 반환합니다.  
3. `double answer = accumulate(...)`  
* `accumulate` 결과를 `double`형 변수 `answer`에 저장합니다.  
* 하지만 여기서는 초기값인 `0`이 정수 이므로, 사실상 `accumulate`는 정수 덧셈을 수행하고, 그 결과를 `double`로 변환하는 형태입니다.  
4. `return answer / arr.size();`  
* 누적한 합계 `answer`를 `arr` 크기로 나누어 평균값을 구해 반환합니다.

---

#### **작동 요약**

* `accumulate` 함수가 배열의 모든 원소를 더하고,  
* 그 합을 배열 길이로 나눠 평균을 계산해 돌려줍니다.

---

#### **참고사항**

* 초기값 `0` 대신 `0.0`으로 주면, `accumulate` 과정에서부터 실수형 연산이 되어 더 안전합니다.  
* 현재 `0`이 정수라 C++은 모든 덧셈을 정수로 하다가 마지막에 `double`로 변환하는데, 큰 합계일 때 오버플로우 위험이 있습니다.  
* 배열 크기 조건 내에서는 큰 문제 없지만, `0.0`으로 초기값 주기를 권장합니다.

---

# ***⬛짝수와 홀수***

##### **문제 설명**

정수 num이 짝수일 경우 "Even"을 반환하고 홀수인 경우 "Odd"를 반환하는 함수, solution을 완성해주세요.

##### **제한 조건**

* num은 int 범위의 정수입니다.  
* 0은 짝수입니다.
 ```cpp
 #include <string>
 #include <vector>
 
 using namespace std;
 
 string solution(int num) 
 {
     if(num % 2 == 0)
     {
         return "Even";
     }
     else
     {
         return "Odd";
     }
 }
 ```
\-\>다른 풀이 
 ```cpp
 string solution(int num) 
 {
     string answer = "";
 
     return num & 1 ? "Odd" : "Even";
 }
 ```


### **1\. `string answer = "";`**

* 이 줄은 빈 문자열을 저장하는 `answer` 변수를 선언한 것인데, 사실 여기서는 사용하지 않고 바로 반환문이 있어 무의미합니다. 이 줄은 없어도 코드 실행에 영향 없습니다.

### **2\. `return num & 1 ? "Odd" : "Even";`**

이 부분이 핵심입니다.

* `num & 1` 은 비트 연산자 `&`(AND) 를 이용한 표현입니다.  
* `num`의 이진수 표현에서 맨 마지막 비트(최하위 비트)를 1과 AND 연산 하는 뜻입니다.  
* 비트 최하위 자리(LSB)는 짝수인지 홀수인지를 나타내는 중요한 위치입니다:  
  * 짝수: 최하위 비트가 0 (`...0`)  
  * 홀수: 최하위 비트가 1 (`...1`)

따라서,

* `num & 1` 결과가 1이면 (참) → 홀수 → `"Odd"` 반환.  
* 0이면 (거짓) → 짝수 → `"Even"` 반환.

삼항 연산자 형식:  
`(조건) ? (참일 때 값) : (거짓일 때 값)`

---

# ***⬛배열의 평균***

정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소의 평균값을 return하도록 solution 함수를 완성해주세요.

##### **제한사항**

* 0 ≤ numbers의 원소 ≤ 1,000  
* 1 ≤ numbers의 길이 ≤ 100  
* 정답의 소수 부분이 .0 또는 .5인 경우만 입력으로 주어집니다.
 ```cpp
 #include <string>
 #include <vector>
 
 using namespace std;
 
 double solution(vector<int> numbers) 
 {
     int sum = 0;
     for (int num : numbers)
     {
         sum += num;
     }
     return static_cast<double>(sum) / numbers.size();
 }
 ```

1. `for (int num : numbers)` → 배열의 각 원소를 하나씩 꺼냄.

2. `(double)sum / numbers.size()` → `sum`을 `배열 길이`로 나눠 평균 구하기.  
   * ⚠ `sum`과 `size()` 둘 다 정수이므로, 그냥 나누면 정수 나눗셈 처리됩니다.  
   * 👉 `static_cast<double>(sum)`으로 강제로 실수형 변환을 해주어야 소수점까지 계산됩니다.

**for (int num : numbers) 구문**은 \*\*C++11에서 도입된

 "범위 기반 for문(range-based for loop)"입니다.

---

### **작동 원리**

* `numbers`라는 배열(혹은 vector와 같은 컨테이너)의 모든 원소를 하나씩 차례로 꺼내서, 반복문 블록(중괄호 `{}`) 안에서 사용합니다.  
* `num`은 매 반복마다 `numbers`의 각 원소 값을 대입받는 일시적인 변수 역할을 합니다.

### **핵심 포인트 요약**

* 간결함: 인덱스(예: `numbers[i]`)를 직접 사용할 필요 없이, 알아서 모든 원소를 반복해줌.  
* 자료형: 원소의 타입에 맞게 변수 타입을 맞춰야 함. `numbers`가 `int`면 `int num`, `double`이면 `double num` 등.  
* 읽기 전용: 이 방식으로 얻은 `num`은 복사본이므로, 반복문 안에서 `num` 값을 바꿔도 원래 배열에는 영향 없음. 원본을 바꿔야 하면 `int& num : numbers`처럼 참조형(&)을 써야 함.


</details>

<details>
<summary> 스파르타 알고리즘 코드카다 오답정리 문서 링크 </summary>
 
https://docs.google.com/document/d/1nYZwhJ0aFKjDLFxCzBuOu9uQt7LbmihsMFfnZjuVrdc/edit?usp=sharing

</details>
